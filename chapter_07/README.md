# Chapter 07. 트랜잭션
- - -

## ACID

### Atomicity (원자성)
* 다중 스레드 프로그래밍에서 한 스레드가 원자적 연산을 실행하면 다른 스레드에서는 절반만 완료된 연산은 관찰할 수 없다.
* 시스템은 연산을 실행하기 전이나 후의 상태만 존재할 수 있다.

### Consistency (일관성)
* 일관성이라는 단어는 여러 의미로 쓰인다.
  * 복제 일관성은 비동기식으로 복제되는 시스템에서 최종적 일관성을 유지하며, 복제 지연이 발생할 수 있다. 
  * 일관성 해싱은 시스템들에서 리밸런싱을 위해 사용하는 파티셔닝 방법이다.
  * CAP에서 일관성이라는 단어는 선형성을 의미한다.
  * ACID의 맥락에서의 일관성은 데이터베이스가 변경 사항에 대해 무결하게 적용되어야 한다는 개념이다.

### Isolation (격리성)
* 동시에 실행되는 트랜잭션에 대해서 격리되어야 하는 성질이다.
* 트랜잭션이 격리되지 않으면 한 테이블의 같은 로우에 대해 두 트랜잭션이 동시에 접근하여 데이터를 수정했을 때, 트랜잭션의 변경 사항이 유실될 수 있다.
![img.png](images/isolate_exam.png)
* 격리 수준을 직렬화하면 이러한 문제를 방지할 수 있지만 성능상의 손해가 있기 떄문에 시스템 활동성이 저하될 수 있다.

### Durability (지속성)
* 트랜잭션이 성공했다면 데이터베이스에 영구히 보관되어야 한다.

### 단일 객체 쓰기
* 저장소 엔진들은 거의 보편적으로 한 노드에 존재하는 (키-값 쌍 같은) 단일 객체 수준에서 원자성과 격리성을 제공하는 것을 목표로 한다.
* 원자성은 장애 복구용 로그를 써서 구현할 수 있고, 격리성은 각 객체에 잠금을 사용해 동시에 한 스레드만 객체에 접근하도록 하여 구현할 수 있다.
* 단일 객체 연산은 여러 클라이언트가 동시에 같은 객체에 쓰려고 할 때 갱신 손실을 방지한다.

### 오류와 중단 처리
* 트랜잭션의 핵심은 오류가 생기면 중단되고 안전하게 재시도할 수 있다는 것이다.
  * 하지만 모든 시스템이 이 철학을 따르지는 않는다.
* 중단된 트랜잭션을 재시도하는 것은 완벽하지는 않다.
  * 트랜잭션이 실제로 성공했지만 서버가 클라이언트에게 커밋 성공을 알리는 도중 네트워크가 끊겼을 때, 클라이언트는 실패했다고 생각하여 재시도하면 트랜잭션이 두 번 실행될 수 있다.
  * 오류과 과부화 떄문이라면 트랜잭션의 재시도는 문제를 개선하는게 아니라 악화시킬 수 있다. 이런 문제는 재시도 횟수를 제한하든지 지수적 백오프를 사용하여 처리하는 방법이 있다.
  * 일시적인 오류(데드락, 격리성 위반, 일시적인 네트워크 단절, 장애 복구)만 재시도할 가치가 있으며 영구적인 오류는 재시도해도 소용이 없다.
  * 트랜잭션이 데이터베이스 외부에도 부수 효과가 있다면 트랜잭션이 중단될 때도 부수 효과가 실행될 수 있다.
  * 클라이언트 프로세스가 재시도 중에 죽어버리면 해당 데이터가 모두 손실된다.

### 완화된 격리 수준
* 동시성 버그는 타이밍에 운이 없을 때만 촉발되기 때문에 테스트로 발견하기 어렵다.
  * 직렬성 격리로 동시성 문제는 해결되지만 성능 비용이 크다.
  * 따라서 어떤 동시성 이슈로부터는 보호해주지만 모든 이슈로부터 보호해주지는 않는, 완화된 격리 수준을 사용하는 시스템이 흔하다.

### Read Committed
* 가장 기본적인 수준의 트랜잭션 격리 수준으로 아래의 두 가지를 보장한다.
  * 데이터베이스에서 읽을 때 커밋된 데이터만 보게 된다. (더티 리드 방지)
  * 데이터베이스에 쓸 때 커밋된 데이터만 덮어쓰게 된다. (더티 쓰기 방지)
* 더티 리드 방지
  * 트랜잭션이 쓴 내용은 커밋된 후에야 다른 트랜잭션에서 관찰될 수 있다.
  * 트랜잭션이 여러 객체를 갱신하는데 더티 읽기가 생기면 다른 트랜잭션이 일부는 갱신된 값을, 일부는 갱신되지 않은 값을 볼 수 있다.
  * 트랜잭션이 중단되면 그때까지 쓴 내용은 모두 롤백돼야 한다. 만약 더티 리드를 허용하면 트랜잭션이 나중에 롤백될 데이터를 볼 수 있게 된다.
* 더티 쓰기 방지
  * 아직 커밋되지 않은 트랜잭션에서 쓴 작업을 나중에 실행된 쓰기 작업이 커밋되지 않은 값을 덮어써버리게 되는 현상을 더티 쓰기라고 한다.
  * 보통 먼저 쓴 트랜잭션이 커밋되거나 중단될 때까지 두 번째 쓰기를 지연시키는 방법을 사용한다.
* 하지만 Read Committed는 레이스 컨디션에서 발생하는 갱신 손질을 막지 못한다.

### 스냅숏 격리와 반복 읽기
* Read Committed 격리 수준은 아래와 같이 동시성 문제가 발생할 수 있다.
![img.png](images/read_committed_issue.png)
* Transaction 1 은 현재 계좌 1, 2의 잔고 합이 900원인 것처럼 보이지만 실제로는 1000원 그대로이다.
* 이러한 현상을 unrepeatable read나 read skew라고 한다.
* 스냅숏 격리는 각 트랜잭션이 데이트베이스의 일관된 스냅숏으로으로부터 읽는다.
  * 즉 트랜잭션이 시작할 때 데이터베이스에 커밋된 상태였던 모든 데이터를 본다.
  * 데이터가 나중에 다른 트랜잭션에 의해 바뀌더라도 각 트랜잭션은 특정한 시점의 과거 데이터를 볼 뿐이다.
  * 스냅숏 격리는 백업이나 분석처럼 실행하는 데 오래 걸리며 읽기만 실행하는 질의에 유용하다. (질의가 실행 중일 때 동시에 대상 데이터가 변경되면 해당 질의의 의미에 대해 추론하기가 매우 어려움)

### 스냅숏 격리 구현
* 성능 관점에서 스냅숏 격리의 핵심은 읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다는 것이다.
  * 데이터베이스는 잠금 경쟁 없이 쓰기 작업이 일상적으로 처리되는 것과 동시에 일관성 있는 스냅숏에 대해 오래 실행되는 읽기 작업을 처리할 수 있다.
* 스냅숏 격리를 구현하는 방법으로 MVCC 기법을 사용한다. (Multi-version concurrency control)
* MVCC의 트랜잭션 처리 방법
  * 트랜잭션이 시작하면 계속 증가하는 고유한 트랜잭션 ID(txid)를 할당받는다.
  * 트랜잭션이 데이터베이스에 데이터를 쓸 때마다 쓰기를 실행한 트랜잭션의 ID가 함께 붙는다.
  * 테이블의 각 로우에는 그 로우를 테이블에 삽입한 트랜잭션 ID를 갖는 created_by 필드가 있고, 각 로우에는 처음에는 비어있는 deleted_by 필드가 있다.
  * 트랜잭션이 로우를 삭제하면 실제로 데이터베이스에서 지우지 않고 deleted_by 필드를 삭제 요청 트랜잭션의 ID로 설정하여 논리적으로 표시한다.
  * 나중에 아무 트랜잭션도 더 이상 삭제된 데이터에 접근하지 않는 게 확실해지면 데이터베이스의 가비지 컬렉션 프로세스가 지워졌다고 표시된 로우들을 삭제하여 사용량을 줄인다.
  * 갱신은 내부에서 삭제와 생성으로 변환한다.
![img.png](images/mvcc_exam.png)
* 위의 플로우에서 txid=12인 트랜잭션은 계좌2의 잔액을 읽어 갈 때, 자신의 txid보다 작은 스냅숏에 대해서만 읽기를 수행한다.
  * 이렇게 함으로써 txid=13인 트랜잭션이 update하여 새로운 스냅숏을 쓰더라도 txid=12 트랜잭션은 잔액이 500원인 스냅숏을 일관성 있게 읽어갈 수 있게 된다.

### 일관된 스냅숏을 보는 가시성 규칙
1. 데이터베이스는 각 트랜잭션을 시작할 때 그 시점에 진행중인(아직 커밋이나 중단되지 않은) 모든 트랜잭션의 목록을 만든다. 이 트랜잭션들이 쓴 데이터는 모두 무시된다. (데이터를 쓴 트랜잭션이 나중에 커밋되더라도 마찬가지)
2. 중단된 트랜잭션이 쓴 데이터는 모두 무시된다.
3. 트랜잭션 ID가 더 큰 트랜잭션이 쓴 데이터는 그 트랜잭션의 커밋 여부에 관계 없이 모두 무시된다.
4. 그 밖의 모든 데이터는 애플리케이션의 질의로 볼 수 있다.

* 데이터베이스는 갱신할 때 값을 교체하지 않고 값이 바뀔 때마다 새 버전을 생성함으로써 작은 오버헤드만 유발하면서 일관된 시냅숏을 제공할 수 있다.

### 색인과 스냅숏 격리
* 다중 버전 데이터베이스에서 색인이 동작하는 하나의 선택지는 단순하게 색인이 객체의 모든 버전을 가리키게 하고 색인 질의가 현재 트랜잭션에서 볼 수 없는 버전을 걸러내게 하는 것이다.
* B 트리의 변종으로, 추가 전용이며 쓸 때 복사(append-only/copy-on-write)되는 색인 방법은 쓰기를 실행하는 모든 트랜잭션은 새로운 B 트리 루트를 생성한다.
  * 특정 루트는 그것이 생성되는 시점에 해당하는 데이터베이스의 일관된 스냅숏이 된다.
  * 나중에 실행되는 쓰기는 새로운 트리 루트만 생성할 수 있고 존재하는 B 트리를 변경할 수 없으므로 트랜잭션 ID를 기반으로 객체를 걸러낼 필요가 없다.
  * 하지만 컴팩션과 가비지 컬랙션을 실행하는 백그라운드 프로세스가 필요하다.

### 갱신 손실 방지
* 갱신 손실 문제는 두 트랜잭션이 작업을 동시에 하면 두 번째 쓰기 작업이 첫 번째 작업 변경을 포함하지 않으므로 변경 중 하나는 손실될 수 있다.
* 갱신 손실 문제는 애플리케이션에서 값을 읽고 변경한 후에 변경된 값을 다시 쓸 때 발생할 수 있다. (read-modify-write 주기)

### 원자적 쓰기 연산
* 데이터베이스에서 원자적 갱신 연산을 제공하면 read-modify-write 주기를 구현할 필요를 없애준다.
* 예를 들어 다음 명령은 대부분의 관계형 데이터베이스에서 동시성 안전(concurrency-safe)하다.
> UPDATE counters SET value = value + 1 WHERE key = 'foo';
* 원자적 연산은 보통 객체를 읽을 때 그 객체에 exclusive lock을 획득하여 갱신이 적용될 때까지 다른 트랜잭션에서 그 객체를 읽지 못하게 한다.
* 다른 선택지는 모든 원자적 연산을 단일 스레드에서 실행되도록 강제하는 것이다. (성능에 좋지 않을 것 같다.)

### 명시적 잠금
```sql
BEGIN TRANSACTION;
SELECT *
FROM figures
WHERE name = 'robot' AND game_id = 222
FOR UPDATE;

UPDATE figures SET position = 'c4' WHERE id = 1234;
```
* FOR UPDATE 절은 데이터베이스가 이 질의에 의해 반환된 모둔 로우에 잠금을 획득하도록 한다.
* 하지만 레이드 컨디션을 유발할 가능성이 크므로 주의해야 한다.

### Compare-and-set
* Compare and set은 값을 마지막으로 읽은 후로 변경되지 않았을 때만 갱신을 허용함으로써 갱신 손실을 회피하는 것이다.
  * ex) java의 concurrent hashmap, atomic integer가 있다.
* 단, 데이터베이스가 WHERE 절이 오래된 스냅숏으로부터 읽는 것을 허용한다면 갱신 손실을 막지 못할 수 있다.

### 충돌 해소와 복제
* 다중 리더 또는 리더 없는 복제를 사용하는 데이터베이스는 쓰기가 동시에 실행되고 비동기식으로 복제되는 것을 허용하므로 데이터의 최신 복자본이 하나만 있으리라고 보장할 수 없다.
* 쓰기가 동시에 실행될 때 한 값에 대해서 여러 개의 충돌된 버전을 생성하는 것을 허용하고 사후에 애플리케이션 코드나 특별한 데이터 구조를 사용해 충돌을 해소하고 이 버전들을 병합하는 방법이 있다.
* 반면 최종 쓰기 승리(last write wins, LWW) 충돌 해소 방법은 갱신 손실이 발생하기 쉽다. (많은 복제 데이터베이스는 LWW가 기본 설정이다.)

### 쓰기 스큐
![img.png](images/write_skew.png)
* 위 그림은 on call 사람이 최소 1명 이상이 있어야 한다고 존재할 때, 쓰기 스큐에 의해 발생하는 문제이다.
* 쓰키 스큐는 두 트랜잭션이 같은 객체들을 읽어서 그중 일부를 갱신할 때 나타날 수 있다.
  * 다른 트랜잭션이 다른 객체를 갱신했으므로 더티 쓰기도 아니고 갱신 손실도 아니다.
* 직렬성 격리 수준을 사용할 수 없다면 트랜잭션이 의존하는 로우를 명시적으로 잠그는 것이 차선책이다. (FOR UPDATE)

### 쓰기 스큐를 유발하는 팬텀
1. SELECT 질의가 어떤 검색 조건에 부합하는 로우를 검색함으로써 어떤 요구사항을 만족하는지 확인한다.
2. 첫 번째 질의의 결과에 따라 애플리케이션 코드는 어떻게 진행할지 결정(해당 연산을 계속 처리할지 오류를 보고하고 중단할지)한다.
3. 애플리케이션이 계속 처리하기로 결정했다면 데이터베이스에 쓰고(INSERT, UPDATE, DELETE) 트랜잭션을 커밋한다. 이 쓰기를 효과로 인해 1단계의 SELECT 질의를 재실행하면 다른 결과를 얻게 된다.
* 위 과정은 다른 순서로 일어날 수도 있다. (쓰기 먼저 실행하고 SELECT 질의를 실행하는 경우)
* 어떤 검색 조건에 부합하는 로우가 존재하지 않는지 확인하고 쓰기 작업이 같은 조건에 부합하는 로우를 추가하는 경우에 1단계의 질의가 아무 로우도 반환하지 않으면 SELECT FOR UPDATE는 아무것도 잠글 수 없다.
* 이처럼 어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과를 팬텀이라고 한다.
  * 스냅숏 격리는 읽기 전용 질의에서는 팬텀을 회피하지만 읽기 쓰기 트랜잭션에서는 팬텀이 쓰기 스큐를 유발할 수 있다.

### 충돌 구체화
* 팬텀의 문제가 잠글 수 있는 객체가 없는 것이라면 인위적으로 데이터베이스에 잠금 객체를 추가하여 문제를 해결할 수도 있다.
* 인위적으로 추가한 테이블은 잠금을 획득하는데 사용함으로써 새로운 데이터를 삽입할 수 있게 된다. 이를 충돌 구체화(Materializing conflict)라고 한다.
