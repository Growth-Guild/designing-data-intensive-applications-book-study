# Chapter 09. 일관성과 합의

## 일관성 보장
* 두 대 이상의 데이터베이스 노드를 바라본다면 두 노드에서 서로 다른 데이터를 볼 가능성이 크다.
  * 다른 노드들에 쓰기 요청이 도착하는 시간이 다르기 때문이다.
  * 이러한 불일치는 데이터베이스가 어떤 복제 방법(단일 리더, 다중 리더, 리더 없는 복제 등)을 쓰느냐에 상관 없이 일어난다.
* 복제 데이터베이스는 대부분 최종적 일관성을 제공한다.
  * 그러나 언제 복제본이 수렴될지에 대해서는 알 수 없다.
  * 이러한 일관성은 약한 보장이다.
  * 강한 보장을 제공하는 시스템은 성능이 나쁘거나 약한 보장을 제공하는 시스템보다 내결함성이 약할지도 모르지만, 올바르게 사용하기 쉬우므로 매력적이다.
* 트랜잭션 격리는 주로 동시에 실행되는 트랜잭션 때문에 발생하는 경쟁 조건을 회피하는 것에 관한 것이지만 분산 일관성은 대개 지연과 결함이 있더라도 복제본의 상태를 코디네이션하는 것에 관한 것이다.

## 선형성
* 선형성은 "데이터베이스가 복제본이 하나만 있다"라는 아이디어를 기반으로 한다.
  * 원자적 일관성(atomic consistency), 강한 일관성(strong consistency), 즉각 일관성(immediate consistency), 외부 일관성(external consistency)라고도 한다.
* 즉, 선형성은 최신성 보장(recency guarantee)이다.

![non_linearizability](images/non_linearizability.png)
* 위 그림은 비선형성이라서 발생하는 문제를 보여준다.
  * 앨리스와 밥이 동시에 웹 페이지를 새로 불러와서 각자 다른 결과를 받았다면 이상하지 않았을 것이다.
  * 그러나 앨리스가 최종 결과를 외친 후에 밥이 이 결과를 확인하려 들면서 괴리가 발생했다는 것을 인지하게 된다.
* 선형성은 한 클라이언트에서 최초로 값이 변경되었음을 관측했다면 다른 클라이언트에서도 변경된 값을 관측할 수 있어야 한다.
![linearizability](images/linearizability.png)
* 선형성의 요구사항은 연산 표시를 모은 선들이 항상 시간순으로 진행돼야 하고 결코 뒤로 가서는 안된다.
  * 이 요구사항은 최신성 보장이 되도록 만들어준다.
* 클라이언트 B의 마지막 읽기는 선형적이지 않다.
  * 다른 요청이 없었다면 B의 읽기는 2여도 괜찮지만, 클라이언트 A가 변경된 4라는 값을 관측했기 때문에 B의 읽기는 4여야 한다. (과거의 값을 읽는 것은 허용되지 않기 때문)

### 선형성과 직렬성
* 직렬성
  * 직렬성은 모든 트랜잭션이 여러 객체를 읽고 쓸 수 있는 상황에서의 트랜잭션들의 격리 속성이다.
  * 직렬성은 트랜잭션들이 어떤 순서에 따라 실행되는 것처럼 동작하도록 보장해준다. 그 순서가 트랜잭션들이 실제로 실행되는 순서와 달라도 상관없다.
* 선형성
  * 레지스터(개별 객체)에 실행되는 읽기와 쓰기에 대한 최신성 보장이다.
  * 선형성은 연산을 트랜잭션으로 묶지 않아서 충돌 구체화 같은 부가적인 수단을 사용하지 않으면 쓰기 스큐 같은 문제를 막지 못한다.

## 선형성을 위한 요구사항
### 잠금과 리더 선출
* 단일 리더 복제를 사용하는 시스템은 리더가 하나만 존재하도록 보장해야 한다.
* 리더를 선출하는 한 가지 방법은 잠금을 사용하는 것이다.
  * 모든 노드가 시작할 때 잠금을 시도하고 성공한 노드가 리더가 된다.
  * 이 잠금은 선형적이어야 한다.
* 분산 잠금과 리더 선출을 구현하기 위해 아파치 주키퍼나 etcd 같은 코디네이션 서비스가 종종 사용된다.
  * 이들은 합의 알고리즘을 사용해 선형성 연산을 내결함성이 있는 방식으로 구현한다.

### 채널 간 타이밍 의존성
![multi_channel_dependency](images/multi_channel_dependency.png)
* 선형성 위반은 시스템에 부가적인 통신 채널이 있을 때 발견될 수 있다.
* 위의 그림에서 3, 4단계의 메시지 큐가 저장 서비스 내부의 복제가 빠를 수도 있기 때문에 선형성이 위반되는 상황이 발생할 수 있다.

### 선형성 시스템 구현하기
* 선형성은 근본적으로 "데이터 복사본이 하나만 있는 것처럼 동작하고 그 데이터에 실행되는 모든 연산은 원자적"이라는 것을 의미하므로 가장 간단한 해답은 정말로 데이터 복제본을 하나만 사용하는 것이다.
* 그러나 이 방법은 성능과 내결함성 측면에서 좋지 않다.
* 시스템이 내결함성을 지니도록 만드는 가장 흔한 방법은 복제를 사용하는 것이다.

### 복제 방법에 따른 선형성 가능 여부
* 단일 리더 복제 (선형적이 될 가능성이 있음)
  * 리더나 동기식으로 갱신된 팔로워에서 실행한 읽기는 선형적이 될 가능성이 있다.
  * 모든 단일 리더 데이터베이스가 실제로 선형적인 것은 아니다. (설계 때문일 수도 있고(예를 들어 스냅숏 격리를 사용하기 때문에) 동시성 버그 때문일 수도 있다.)
  * 비동기 복제를 사용하면 장애 복구를 할 때 커밋된 쓰기가 손실될 수도 있는데 지속성과 선형성을 모두 위반하는 것이다.
* 합의 알고리즘 (선형적)
  * 합의 프로토콜에는 스플릿 브레인과 복제본이 뒤처지는 문제를 막을 수단이 포함된다.
  * 예를 들어 주키퍼와 etcd가 있다.
* 다중 리더 복제 (비선형적)
  * 다중 리더 복제를 하는 시스템들은 일반적으로 선형적이지 않다.
  * 여러 노드에서 동시에 쓰기를 처리하고 그렇게 쓰여진 내용을 비동기로 다른 노드에 복제하기 때문이다.
* 리더 없는 복제 (아마도 비선형적)
  * 정족수 읽기와 쓰기를 요구함으로써 엄격한 일관성을 달성할 수 있을 것처럼 보이지만, 정족수의 정확한 설정에 따라, 그리고 엄격한 일관성을 어떻게 정의하느냐에 따라 비선형적이게 된다.
  * 일 기준 시계를 기반으로한 "최종 쓰기 승리" 충돌 해소 방법은 비선형적이다. 시계 타임스탬프는 시계 스큐 때문에 이벤트의 실제 순서와 일치하리라고 보장할 수 없기 때문이다.
  * 느슨한 정족수도 선형성의 가능성을 망친다. 엄격한 정족수를 사용해도 비선형적으로 동작할 가능성이 있다.

### CAP 정리
* 일관성(Consistency), 가용성(Availability), 분단 내성(Partition tolerance) 세 가지 특성 중 두 가지만 선택할 수 있는 것으로 표현되어 오해가 많이 발생한다.
* 네트워크 분단은 일종의 결함이므로 선택할 수 있는 뭔가가 아니다. 네트워크 분단은 좋은 싫든 발생한다.
* 네트워크가 올바르게 동작할 때는 시스템이 일관성과 완전한 가용성 모두를 제공할 수 있지만, 네트워크 결함이 생기면 선형성과 완전한 가용성 사이에서 선택해야 한다.
* 따라서 CAP는 네트워크 분단이 생겼을 때 일관성과 가용성 중 하나를 선택하라는 의미로 보는 것이 좋다.

## 순서화 보장
* 선형성은 데이터 복사본이 하나만 있는 것처럼 동작하고 모든 연산이 원자적으로 효과가 나타나는 것처럼 보이는 것이라고 정리했다.
* 선형성의 정의는 연산들이 잘 정의된 순서대로 실행한다는 것을 암시하며, 순서화는 선형성의 근본적인 아이디어다.

### 순서화와 인과성
* 순서화는 인과성을 보존하는데 도움을 준다.
* 인과성은 이벤트에 순서를 부과한다. 결과가 나타나기 전에 원인이 발생한다.
* 시스템이 인과성에 의해 부과된 순서를 지키면 그 시스템은 인과적으로 일관적(causally consistent)이라고 한다.

### 인과적 순서가 전체 순서는 아니다
* 전체 순서는 어떤 두 요소를 비교할 수 있게 하므로 두 요소가 있으면 항상 크고 작은 것을 비교할 수 있다.
* 하지만 비교가 불가하여 부분적으로만 순서가 정해지는 경우도 있다.
* 전체 순서와 부분 순서의 차이점은 다른 데이터베이스 일관성 모델에 반영된다.
* 선형성
  * 선형성 시스템에서는 연산의 전체 순서를 정할 수 있다.
  * 시스템이 데이터 복사본이 하나만 있는 것처럼 동작하고 모든 연산이 원자적이면 어떤 두 연산에 대해 항상 둘 중 하나가 먼저 실행됐다고 말할 수 있다는 뜻이다.
* 인과성
  * 두 이벤트에 인과적인 관계가 있으면 이들은 순서가 있지만 이들이 동시에 실행되면 비교할 수 없다.
  * 인과성이 전체 순서가 아닌 부분 순서를 정의한다는 뜻이다.

### 선형성은 인과적 일관성보다 강하다
* 선형성은 인과성을 내포한다. 어떤 시스템이든지 선형적이라면 인과성도 올바르게 유지한다.

### 인과적 의존성
* 인과성을 유지하기 위해서는 어떤 연산이 어떤 다른 연산보다 먼저 실행됐는지 알아야 한다.

### 일련번호 순서화
* 일련번호나 타임스탬프를 써서 이벤트의 순서를 정함으로써 인과성을 유지할 수 있다.
* 타임스탬프는 일 기준 시계에서 얻을 필요는 없고, 논리적 시계에서 얻어도 된다.
  * 논리적 시계는 연산을 식별하는 일련번호를 생성하는 알고리즘이고 보통 모든 연산마다 증가하는 카운터를 사용한다.
* 일련번호나 타임스탬프는 크기가 작고 전체 순서를 제공한다.
* 단일 리더 복제를 쓰는 데이터베이스에서는 복제 로그가 인과성에 일관적인 쓰기 연산의 전체 순서를 정의한다.

### 램포트 타임스탬프
![lamport](images/lamport.png)
* 램포트 타임스탬프는 인과성에 일관적인 일련번호를 생성하는 방법이다. 
1. 각 노드는 고유 식별자를 갖고 각 노드가 처리한 연산의 개수를 카운터로 유지한다. 
2. 램포트 타임스탬프는 (카운터, 노드 ID)의 쌍이다. 
3. 두 노드는 카운터 값이 같을 수 있지만 타임스탬프에 노드 ID가 포함되어 있으므로 유일하다.
* 두 타임스탬프가 있으면 카운터가 큰 것이 타임스탬프가 크다. 카운터 값이 같으면 노드 ID가 큰 것이 타임 스탬프가 크다.
* 모든 노드와 모든 클라이언트가 지금까지 본 카운터 값 중 최대값을 추적하고 모든 요청에 그 최댓값을 포함시킨다.
* 노드가 자신의 카운터 값보다 큰 최대 카운터를 가진 요청이나 응답을 받으면 바로 자신의 카운트를 그 최대값으로 증가시킨다.

### 타임스탬프 순서화로는 충분하지 않다.
* 사용자명으로 사용자 계정을 유일하게 식별할 수 있도록 보장해야할 때
  * 노드가 사용자로부터 사용자명 생성 요청을 받고 그 요청이 성공해야 하는지 실패해야 하는지 당장 결정해야 할 때, 모든 연산을 모은 후에 전체 순서를 비교하면 순서를 결정할 수 있지만, 그 전에는 알 수 없다.
  * 즉, 순서가 존재한다는 것 만으로는 충분하지 않고, 그 순서가 언제 확정되느냐가 중요하다.

### 전체 순서 브로드캐스트
* 전체 순서 브로드캐스트는 분산 시스템에서 모든 노드들이 연산의 전체 순서가 동의하도록 합의하는 방법이다.
* 전체 순서 브로드캐스트는 아래의 속성을 만족해야 한다.
  * 신뢰성 있는 전달 : 어떤 메시지도 손실되지 않아야 한다. 메시지가 한 노드에 전달되면 모든 노드에 전달된다.
  * 전체 순서가 정해진 전달 : 메시지는 모든 노드에 같은 순서로 전달된다.
* 주키퍼나 etcd 같은 합의 서비스는 전체 순서 브로드캐스트를 실제로 구현한다.
* 전체 순서 브로드캐스트는 메시지가 전달되는 시점에 그 순서가 고정된다는 것이다.
* 후속 메시지가 이미 전달됐다면 노드는 그 순서의 앞에 메시지를 소급적으로 끼워넣는 게 불가능하다.

### 분산 트랜잭션과 합의
* 합의의 목적은 노드들이 뭔가에 동의하게 만드는 것이다.
* 합의에는 아래와 같은 상황에서 필요하다.
  * 리더 선출
  * 원자적 커밋

### 2단계 커밋 (two phase commit)
* 2단계 커밋은 여러 노드에 걸친 원자적 트랜잭션 커밋을 달성하도록 보장하는 알고리즘이다.
* 노드간의 트랜잭션 보장을 위해 코디네이터가 필요하다.
* 코디네이터에 장애 발생 시, 노드들은 코디네이터가 복구되기를 기다려야 한다.

### 내결함성을 지닌 합의
* 합의 알고리즘은 다음 속성을 만족해야 한다.
  * 균일한 동의 : 어떤 두 노드도 다르게 결정하지 않는다.
  * 무결성 : 어떤 노드도 두 번 결정하지 않는다.
  * 유효성 : 한 노드가 값 v를 결정한다면 v는 어떤 노드에서 제안된 것이다.
  * 종료 : 죽지 않은 모든 노드는 결국 어떤 값을 결정한다.
* 종료 속성은 어떤 노드들에 장애가 나더라도 다른 노드들은 여전히 결정을 내리도록 하여 내결함성의 아이디어를 형식화한다.
* 알고리즘이 견딜 수 있는 장애의 수에는 제한이 있다.
  * 종료를 보장하려면 최소한 노드의 과반수가 올바르게 동작해야 한다.
  * 따라서 종료 속성은 죽거나 연결할 수 없는 노드 대수가 절반 미만이라는 가정에 종속적이다.
